# 继承

1. extends继承

2. super关键字

   1. 调用构造方法
   2. 调用方法

3. 多态

   1. java中，对象变量是多态的：一个变量可以引用多种实际类型
   2. 父类类型的变量，可以引用子类的对象（因为子类一定是父类（eg：经理属于雇员）父类是子类的超集）
   3. 但是引用了之后，不能使用子类独有的方法（可能访问不存在的实例域，扰乱相邻内存）

   ```shell
           staff[1] = new Manager("Harry", 10000, 1989, 10, 1);
   //        staff[1].setBonus(10000); // 不存在，将子类引用赋给一个声明类型为父类的是可以的，但是如果是在数组中，那么一但调用子类独有方法，那么就会访问不属于它的内存，不对！
   
           Employee e = new Manager("Harry", 10000, 1989, 10, 1);
           
   ```

   

4. 方法调用的过程：x.f(arg) x是对象，f是方法名，args是传参

   1. Java中方法签名：方法名+参数类型组成的列表为一个方法签名（返回类型不算）
   2. 静态绑定
      1. 如果是private、static、final修饰的，那么虚拟机直接定位到方法，调用，称为静态绑定
   3. 动态绑定
      1. 首先java虚拟机会给每个类生成给方法表
      2. 假设调用e.getSalary("test") 会首先搜索e指向的实例类型，以及其父类类型（public范围的）所有名为getSalary的方法，然后在其中找到参数类型是一个String的进行实际调用，如果是找到多个方法、或者找不到就报错
      3. 如果指定了super（）就直接找父类的方法表

5. final修饰符

   1. 修饰类
      1. 不可从final类继承，从而派生出子类，String就是final修饰的，**意味，如果一个对象引用是String类型，那么它引用的一定是java内置的String类型，而不是谁派生定义的子类**
      2. **final修饰的类，它所有的方法自动都是final的，但域不会**
   2. 修饰方法
      1. 子类不可覆盖父类中被final修饰的方法，**作用：避免子类修改父类中某方法实现，比如Calander的getTime方法，让这个方法语义实现，把控在父类手中**
      2. 
   3. 修饰域
      1. 该值不可被修改：值类型不可被修改；引用类型，引用的对象不可变（对象本身的内容可变）

6. 强制类型转换

   1. 高精度向低精度转换（因为：可能丢失精度）
   2. 父类向子类转换（因为：可能访问子类更丰富的域、方法）

7. 抽象类

   1. why？
      1. 假设在Employee类上抽象一层Person类，给它加一个name域和getter、setter方法，再加一个getDesc（）方法，但是这个方法不好实现，因为很难给Person下定义，给具体的Student、Employee人群可以，那么这个方法就不实现，只起到占位作用，那么就得加一个abstract修饰符，只有一个abstract修饰得方法，那么这个类也得加（它也就是抽象类了）
   2. 特征
      1. 只要有至少一个方法不实现，只占位置，那么这个类就是抽象类
      2. 和接口不同：**抽象类可以有域、可以实现部分方法，但接口没有域、方法也全部是方法签名的定义，两者使用场景？**
   3. 使用场景

8. protected修饰

   1. 可以被派生出的子类访问，（方法、或者域）更多是方法，数据还是private封装更好）；

9. ojbects超类

   1. Objects.euqals()，使用引用类型自己实现的equals要考虑对象为null的情况，而用Objects.equals会考虑到，更方便
   2. 实现equals（）方法的基本步骤@override覆写Object的方法
      1. 先判断2个引用地址是否相同（指向同一个对象，一定相等）
      2. 然后判断要比较的对象是否为null，是null则一定不等
      3. 然后判断get.Class()是否是同属于一个类，不是肯定不定（或者instanceOf（））
      4. 之后要做一个强制类型转换，因为参数为Objects类型，需要转为具体的子类型
      5. 然后判断各个字段的值是否相等，值类型直接==比较、引用类型借助引用类型自带的equals()方法，**考虑字段对象可能为null情况，使用Objects.equals()更好）**
      6. 实现子类的equals（）方法：先super关键字调用父类的实现，判断父类字段是否完全相等，通过了才有必要判断子类的独有字段
   3. 实现equals（）时，使用instanceof还是getClass（）
      1. 主要取决于，对相等的定义，如果需要各个子类自己实现自己的相等比较逻辑，则使用getClass（），首先就是要类一样
      2. 如果需要在父类实现相等语义的判断，则使用instanceOf（），在父类实现equals方法（），并将其定义为final（不允许子类覆盖）父类中一般只考虑各个子类通用的字段，即父类上有的字段进行比较，不考虑各个子类特有字段

10. hashCode()

    1. 也是超类的方法，返回一个int值，Objects中是根据对象内存地址计算hash的，子类可以自己实现
    2. equals（）和hashcode（）应该同时覆写，当两对象equals（）为true时，它们的hashcode值应该一样（如果比较Employee的equals是只用雇员id，那么hashcode（）应该也是只用雇员id）

11. 自动装箱、拆箱（编译器实现，插入了一些方法调用，虚拟机只是执行）

12. **优先使用多态，而非类型信息** 

    1. 比如如下代码，应该考虑使用多态性，action是2种不同类型可能都要执行的方法，那么就给这2种类型定义一个接口或者父类，x的类型定义为这个接口、或者父类，调用时，直接使用x.action（）借助java的多态，的动态绑定机制，找到实际的动作（方法）去执行，还方便扩展

       ```java
       if (x is type1) 
         action1(x);
       else if (x is type2)
         action2(x);
       ```

       

    2. ref:

       ```shell
       6. 使用多态，而非类型信息
       无论什么时候，对于下面这种形式的代码
       if (x is of tupe 1) action; (x);
       else if x( is of type 2) action(x) ;
       都应该考虑使用多态性。 action，与action，表示的是相同的概念吗?如果是相同的概念，就应该为这个概念定义 一 个方法，并将其放置在两个类的超类或接又中，然后，就可以调用
       X.action( ;
       以便使用多态性提供的动态分派机制执行相应的动作
       
       ```

       