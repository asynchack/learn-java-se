# 类

1. oop，将数据放在第一位，先考虑需要哪些数据（数据结构），再考虑操作数据的方式（算法）
2. 实例域、方法：
   1. 就是类的每个对象，独有的数据字段
   2. 所有实例域的集合，就是当前这个对象的“状态”
   3. 向对象发送一个消息（方法调用），它的状态（实例域数据）就可能发生改变）——方法操作了内部自己数据，oop的本质是组件（对象间的message消息传递，即方法调用！）
   4. 封装关键：
        1. 实例域大多定义为private，不能被外部类直接访问，直接通过方法调用（类提供的方法）进行交互，好处：方法接口不变，内部数据可以随意改变存储方式
3. 对象
    1. 3个主要特征：
        1. 标识符
       2.  行为（方法）
       3. 状态（实例域字段）
    4. 对象的行为、状态相互影响（比如订单对象内部的状态**字段**为“已送达”，则不应该再允许调用删除订单条目的**方法**
5. 类之间的关系
    1. 依赖
       2. 比如order类依赖account类，是因为：需要调用account类方法，判断账号信用状态，再判断是否需要继续下订单
   2. 聚合（包含）
      3. order对象包含若干个item对象
   3. 继承
      4. vipOrder类，继承自Order类，添加一些优先处理订单，或者优惠折扣的方法、字段
5. 对象变量
   6. java中，对象变量，不包含对象本身，只是对象变量的引用（内存地址，应该是在堆上！）
   7. new 操作返回的就是一个地址引用
7. 构造器
    1. 和类同名
   2. 没有返回值
   3. 参数可以有0到多个
   4. 一个类可以有多个构造器
   3. 总是跟着new 关键字使用，调用的结果是返回某个类对象的引用
4. 隐式参数
   1. 方法中，第一个参数是隐式传入的，this，代表调用该方法的某个对象的引用，猜测：是这个对象的内存地址，所谓方法和函数的区别，方法就是在函数的基础上，隐式传入了某个类对象的地址，告诉这个函数去针对这个地址的对象做函数操作，就是=方法调用类
2. getter和setter
   1. 封装了私有数据域，要操作、读取，都只能通过我getter和setter，这样数据的调试，只需要看这些方法就行，
   2. 私有数据域，就不会被可能不知道哪个类对象访问了，修改，而难以定位
   3. 可以拦截、验证操作，比如setSalary，可以限制薪水在某个范围才可以，进行salary字段的修改
4. getter注意事项⚠️
    1. 对于数据域，是引用类型的，比如LocalDate对象，如果直接返回，那么外部就可以直接调用这个对象方法，修改这个LocalDate的值，破坏了封装性
   2. 如何解决：返回引用类型的拷贝！
   3. String类型的特殊，虽然也是引用类型，但是对String对象操作，java隐含的是操作String对象的副本，所以不破坏封装性
4. 基于类的访问权限（一个类的方法，可以访问该类下所有对象的，私有数据域，而不仅仅是当前this的私有数据域，常用于compare方法
    
    ```java
        class Employee {
    private String name;
    private double salary;
    private LocalDate hireDay;

    public boolean sameName(Employee other) {
        
        return this.name.equals(other.name);
        
        // 调用时，harry.sameName(boss) ，方法就会访问到boos的私有数据域，name，是合理的
    }

    public Employee(String name, double salary, int year, int month, int day) {
        this.name = name;
        this.salary = salary;
        this.hireDay = LocalDate.of(year, month, day);

    }

    public String getName() {
        return this.name;
    }

    public double getSalary() {
        return this.salary;
    }

    public LocalDate getHireDay () {
        return this.hireDay;
    }

    public void raiseSalary(double byPercent) {
        double raise = this.salary * byPercent /100;
        this.salary += raise;
    }

    ```
   
11. 私有方法
    1. 公有方法，是暴露给外部调用的接口
    2. 但经常一个公有方法，需要拆一些功能方法（算法类、解密加密等功能函数），它们不需要被外部访问，定义为private 私有方法即可
    3. 只要保证公有方法不受影响，私有方法可以随意增减，理论上
12. final实例域
    1. final 修饰的实例域：表明该字段构造时，必需赋值（或定义时就给定一个值），且赋值后不可更改！
    2. 一般，修饰的实例域，都是基本类型（8种）或不可变类（比如String）（所有修改的方法，都是生成了一个修改后的新的类对象，原对象不变）
    3. 如果  修饰了可变的类，比如StringBuilder，只保证变量不会指向一个新的StringBuilder，但这个StringBuilder对象本身是可以修改数据的哦～
    4. 总结：
        1. final修饰基本数据类型，表示值不可更改，比如int double
       2. final修饰引用数据类型，表示变量引用的对象地址不可以更改（只能引用这个地址），但是这个地址所存储的对象可以任意更改自己的状态（实例数据域）
       3. final修饰方法，表示方法不可以被子类 重写！
       4. finla修饰类，表示类不可以 被继承！
13. static修饰符
    1. static修饰的变量，或常量，是属于类的，类的所有对象都可以访问，但存储只有一份，和类放在一起，比如Math.PI
    2. static修饰的方法：是静态方法，通过类名.方法（）就可以直接调用，不需要实例化一个对象后，通过对象再去调用
       3. 操作的是类的静态域、和对象的实例域没有关系
14. 工厂方法
    1. static 修饰的静态方法，经常用来定义工厂方法，构造一个对象；
    2. 为什么不用构造器？
        1. 构造器，可以更改对象的类型（比如其子类）
       2. 构造器有必需和类同名的限制
15. main（）方法
    1. 也是静态方法，直接通过类调用
    2. 一个程序的入口，一定是某个类的main（）方法
    3. 但！每个类都可以定义自己的main（）方法，用于自己类的单元测试，这样每个类都可以独立调用main方法做unit test！
16. java的方法传参：
    1. 是：call by value，即传递的都是值拷贝，而不是地址
    2. 那么：
        1. 对于值类型，方法内部对值修改，外部的实参，不会受影响，
       2. 对于引用类型，可以传入的是引用类型的内存地址，那么就可以修改引用类型的状态
            1. 并且注意！方法内部，交换2个引用类型的指向，对外部2个引用类型的实参，是无影响的，交换的仅仅是方法内部2个行参的指向，
          2. 也就是，无法在方法内部，让一个引用类型的变量，更改它的指向
17. 对象构造：
    1. 方法重载：
       1.   java，允许存在多个方法名相同，但是行参定义不同的同时存在，overloading，调用时，根据实参传入情况自动匹配到对于的方法，进行调用；方法返回值类型不算方法签名的一部分！
    2. 默认域初始化：
       1. 对象类型默认初始为null，boolean默认为false，数值类型默认为0
       2. 但良好的习惯，应该给确定性的初始值，尤其对于对象类型，避免空指针异常
    3. 无参数构造器
       1. 定义类时，没有定义任何构造器，java会默认加一个无参数构造器，所有域给定该类型的默认值（0、false、null等）
       2. 如果定义类至少一个构造器后，再想使用默认的无参数构造器方法，就必需自己显式定义了（java不给加啦）
    4. 显式的域初始化
       1. 可以定义类时，直接给某个实例域一个初始值（在确认这个类的所有对象，这个字段都应该具有同样的初始值的时候）`private String className = "class 1";` ;这里也可以是方法调用的返回值（静态方法）
    5. 调用其他构造器
       1. this(xx)
    6. 初始化块
        1. java除了，构造器赋值、类定义时赋值，还可以通过初始化块初始化数据域，包含2种
            1. 对象初始化块（实例对象的数据域）
           2. 静态初始化块（类的静态域）
        2. 类对象实例化时，域初始化的顺序
            1. 所有域，初始化为，默认值（0、false、null等）
           2. 然后根据类声明中出现的次序，依次执行：域初始化语句、初始化块
           3. 然后才是，调用构造器
18. finalize（）方法
    1. 给类添加了该方法后，该方法，会在类对象被gc之前调用，做一些资源清理工作，比如释放文件句柄（类似golang的defer？）
19. 包的作用域
    1. public是可以被任意类方法，private是只可以被类本身访问，
    2. 不加这个修饰符呢？是可以被包内其他方法访问，带来的问题：
        1. 可以添加一个恶意的类，类名和java核心类包名一致，然后将类放在核心类的目录下，就可以读取一些忘记加private修饰符的内容类（有危险）（早期）
20. 类路径：
    1. javac编译器和java虚拟机，都有定位java源文件和java类文件的规则，这里先说java虚拟机
    2. java虚拟机，靠类路径定位类
        1. 类路径是一系列：或者；分隔的文件系统路径；默认是当前目录；推荐每次执行时-cp传入（避免全局环境变量的影响）
       2. 第一类：java核心库不用传，java肯定知道；
       3. 第二类；3方库类路径，一般是指定一个文件系统上的jar包，或者一个文件系统上的基目录，然后以这些为根目录，比如需要org.example.Sale类，就会以某个jar包为基，或者某个文件系统目录为基，向下搜索org/example/Sale.class，找到为止，jar包和基本路径都是可以指定任意多个，
       4. 第3类：项目本身的类，以项目根目录为基，搜索和包名层次结构相同的类的位置
       5. idea举例，启动项目时，就会传入这3大类路径：其中依赖3方包，是一个个的jar包,
21. 类设计原则
    1. 一定要保证类数据的私有性
    2. 一定对数据进行明确的初始化，而不依赖默认值（java不对局部变量进行默认初始化，但是对 对象的实例域会进行默认初始化）
    3. 不要使用过多基本类型，比如int改用intger
    4. 合理拆解类
    5. 不是所有域都需要getter和setter
    6. 类名，应该体现它们的职责，一般是形容词+名词比如RushOrder
    7. 优先使用不可变的类，比如：String、java.time包的类、LocalDate类，这样setter方法实际是返回类一个修改后的新对象，并发访问不可变类的对象不会出现冲突
    8. m